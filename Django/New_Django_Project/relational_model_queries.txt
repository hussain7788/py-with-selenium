######### foreign key relationships
###########################################################################
class Language(models.Model):
    name = models.charfield(max_length=20)

class Framework(models.Model):
    name = models.CharField(max=30)
    language = models.ForeignKey(Language, on_delete=models.CASCADE)

## to access Framework language name from language
    . Framework.objects.filter(language__name="python").values()

## to access language Framework
    . language.objects.filter(framework__name="django").values()

#############################################################################


class Movie(models.Model):
    name = models.CharField(max_length=30)

    def __str__(self) -> str:
        return self.name


class Char(models.Model):
    name = models.CharField(max_length=30)
    movie = models.ManyToManyField(Movie)

    def __str__(self) -> str:
        return self.name
####


    from app1.models import *
>>> m = Movie(name="avengers")   
>>> m.save()
>>> c = Char(name="captain")
>>> c.save()
>>> c.movie = m
Traceback (most recent call last):     
  File "<console>", line 1, in <module>
  File "C:\PYTHON\lib\site-packages\django\db\models\fields\related_descriptors.py", line 545, in __set__
    raise TypeError(
TypeError: Direct assignment to the forward side of a many-to-many set is prohibited. Use movie.set() instead.
>>> c.movie.add(m)       
>>> c
<Char: captain>
>>> civil = Movie(name="civil")
>>> thor = Movie(name="thor")
>>> civil_char = Char(name="thor")
>>> civil.save()
>>> thor.save()
>>> civil_char.save()
>>> c.movie.add(civil)
>>> c.movie.add(thor)
>>> Char.objects.all().values()
<QuerySet [{'id': 1, 'name': 'captain'}, {'id': 2, 'name': 'thor'}]>
>>> Movie.objects.all().values()
